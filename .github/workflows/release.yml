name: Create Release

on:
  push:
    branches: [ master ]
    paths-ignore:
      - '**/*.md'
      - '**/*.txt'
      - 'docs/**'
      - '.github/workflows/codeql.yml'

permissions:
  actions: read
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  authenticate:
    runs-on: [ self-hosted, actions-runner ]
    steps:
      - name: Login to DigitalOcean Container Registry
        run: |
          DO_TOKEN=$(cat /opt/github-runner/secrets/do_token)
          echo "::add-mask::$DO_TOKEN"
          echo "$DO_TOKEN" | docker login registry.digitalocean.com --username oauth2 --password-stdin

  release:
    needs: authenticate
    runs-on: [ self-hosted, actions-runner ]
    container:
      image: registry.digitalocean.com/sigil/petros:latest
      options: --user 1000:1000 --group-add 960 --group-add 987
      volumes:
        - /var/run/docker.sock:/var/run/docker.sock
        - /opt/github-runner/secrets:/opt/github-runner/secrets:ro
    defaults:
      run:
        working-directory: ${{ github.workspace }}
    outputs:
      image-digest: ${{ steps.push-do.outputs.digest }}
      build-timestamp: ${{ steps.metadata.outputs.timestamp }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Generate build metadata
      id: metadata
      run: |
        echo "timestamp=$(date +%s)" >> $GITHUB_OUTPUT
        echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

    - name: Load secrets and configuration
      id: load-config
      run: |
        # Load GitHub tokens from runner-local files
        CI_GH_PAT=$(cat /opt/github-runner/secrets/ci_gh_pat)
        CI_GH_CLASSIC_PAT=$(cat /opt/github-runner/secrets/ci_gh_classic_pat)
        echo "::add-mask::$CI_GH_PAT"
        echo "::add-mask::$CI_GH_CLASSIC_PAT"
        echo "CI_GH_PAT=$CI_GH_PAT" >> $GITHUB_ENV
        echo "CI_GH_CLASSIC_PAT=$CI_GH_CLASSIC_PAT" >> $GITHUB_ENV

        # Load registry tokens from runner-local files
        DO_TOKEN=$(cat /opt/github-runner/secrets/do_token)
        DH_TOKEN=$(cat /opt/github-runner/secrets/dh_token)
        echo "::add-mask::$DO_TOKEN"
        echo "::add-mask::$DH_TOKEN"
        echo "DO_TOKEN=$DO_TOKEN" >> $GITHUB_ENV
        echo "DH_TOKEN=$DH_TOKEN" >> $GITHUB_ENV

        # Load GPG secrets from runner-local files
        GPG_PRIVATE_KEY=$(cat /opt/github-runner/secrets/gpg_private_key)
        GPG_PASSPHRASE=$(cat /opt/github-runner/secrets/gpg_passphrase)
        GPG_PUBLIC_KEY=$(cat /opt/github-runner/secrets/gpg_public_key)
        echo "::add-mask::$GPG_PRIVATE_KEY"
        echo "::add-mask::$GPG_PASSPHRASE"
        echo "GPG_PRIVATE_KEY=$GPG_PRIVATE_KEY" >> $GITHUB_ENV
        echo "GPG_PASSPHRASE=$GPG_PASSPHRASE" >> $GITHUB_ENV
        echo "GPG_PUBLIC_KEY=$GPG_PUBLIC_KEY" >> $GITHUB_ENV

        # Load public config from repository
        . .env.maintainer

        # Export to environment for subsequent steps
        echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
        echo "DH_REPO=$DH_REPO" >> $GITHUB_ENV
        echo "ATTIC_SERVER_URL=$ATTIC_SERVER_URL" >> $GITHUB_ENV
        echo "ATTIC_CACHE=$ATTIC_CACHE" >> $GITHUB_ENV
        echo "ATTIC_PUBLIC_KEY=$ATTIC_PUBLIC_KEY" >> $GITHUB_ENV
        echo "VENDOR_BASE_URL=$VENDOR_BASE_URL" >> $GITHUB_ENV

        # Load registry configuration
        . /opt/github-runner/secrets/registry.env

        # Export to environment for subsequent steps
        echo "DO_REGISTRY_NAME=$DO_REGISTRY_NAME" >> $GITHUB_ENV
        echo "DH_USERNAME=$DH_USERNAME" >> $GITHUB_ENV

    - name: Generate release notes
      id: release-notes
      uses: actions/github-script@v7
      with:
        github-token: ${{ env.CI_GH_PAT }}
        script: |
          const generateReleaseNotes = require(
            './.github/scripts/generate-release-notes.js'
          );
          const releaseNotes = await generateReleaseNotes({
            github, context, core
          });
          core.setOutput('RELEASE_NOTES', releaseNotes);

    - name: Build Docker image
      id: build
      env:
        DOCKER_BUILD_ARGS: ${{ env.DOCKER_BUILD_ARGS }}
      run: |
        echo "Building ${{ env.IMAGE_NAME }} image ..."

        # Use .attic_admin_token if it exists, otherwise use attic_token
        if [ -f .attic_admin_token ]; then
          ATTIC_TOKEN_SOURCE=.attic_admin_token
          echo "Using admin attic token"
        else
          ATTIC_TOKEN_SOURCE=attic_token
          echo "Using public attic token"
        fi

        # Compute the attic_token hash for cache busting.
        ATTIC_TOKEN_HASH=$(sha256sum ${ATTIC_TOKEN_SOURCE} | cut -d' ' -f1)

        # Build the image.
        docker build \
          ${DOCKER_BUILD_ARGS} \
          --build-arg ATTIC_SERVER_URL="${{ env.ATTIC_SERVER_URL }}" \
          --build-arg ATTIC_CACHE="${{ env.ATTIC_CACHE }}" \
          --build-arg ATTIC_PUBLIC_KEY="${{ env.ATTIC_PUBLIC_KEY }}" \
          --build-arg VENDOR_BASE_URL="${{ env.VENDOR_BASE_URL }}" \
          --build-arg ATTIC_CACHE_BUST="${ATTIC_TOKEN_HASH}" \
          --secret id=attic_token,src=${ATTIC_TOKEN_SOURCE} \
          -t ${{ env.IMAGE_NAME }}:${{ github.sha }} \
          .
        echo "build_success=true" >> $GITHUB_OUTPUT

    - name: Log into DigitalOcean Container Registry
      if: steps.build.outputs.build_success == 'true'
      run: |
        export DIGITALOCEAN_ACCESS_TOKEN="${{ env.DO_TOKEN }}"
        doctl registry login --expiry-seconds 600

    - name: Push to DigitalOcean Container Registry
      if: steps.build.outputs.build_success == 'true'
      id: push-do
      timeout-minutes: 30
      run: |
        docker tag "${{ env.IMAGE_NAME }}:${{ github.sha }}" \
          "registry.digitalocean.com/${{ env.DO_REGISTRY_NAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        PUSH_OUTPUT=$(docker push \
          "registry.digitalocean.com/${{ env.DO_REGISTRY_NAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" 2>&1)
        echo "$PUSH_OUTPUT"
        DIGEST=$(echo "$PUSH_OUTPUT" | sed -n 's/.*digest: \([^ ]*\).*/\1/p' | head -1)
        echo "digest=${DIGEST}" >> $GITHUB_OUTPUT

    - name: Log into GitHub Container Registry
      if: steps.build.outputs.build_success == 'true'
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ env.CI_GH_CLASSIC_PAT }}

    - name: Push to GitHub Container Registry
      if: steps.build.outputs.build_success == 'true'
      id: push-ghcr
      timeout-minutes: 30
      run: |
        docker tag "${{ env.IMAGE_NAME }}:${{ github.sha }}" \
          "ghcr.io/${{ github.repository }}:${{ github.sha }}"
        PUSH_OUTPUT=$(docker push "ghcr.io/${{ github.repository }}:${{ github.sha }}" 2>&1)
        echo "$PUSH_OUTPUT"
        DIGEST=$(echo "$PUSH_OUTPUT" | sed -n 's/.*digest: \([^ ]*\).*/\1/p' | head -1)
        echo "digest=${DIGEST}" >> $GITHUB_OUTPUT

    - name: Log in to Docker Hub
      if: steps.build.outputs.build_success == 'true'
      run: |
        echo "${{ env.DH_TOKEN }}" | docker login \
          --username "${{ env.DH_USERNAME }}" \
          --password-stdin

    - name: Push to Docker Hub
      if: steps.build.outputs.build_success == 'true'
      id: push-dh
      timeout-minutes: 30
      run: |
        docker tag "${{ env.IMAGE_NAME }}:${{ github.sha }}" \
          "${{ env.DH_USERNAME }}/${{ env.DH_REPO }}:${{ github.sha }}"
        PUSH_OUTPUT=$(docker push "${{ env.DH_USERNAME }}/${{ env.DH_REPO }}:${{ github.sha }}" 2>&1)
        echo "$PUSH_OUTPUT"
        DIGEST=$(echo "$PUSH_OUTPUT" | sed -n 's/.*digest: \([^ ]*\).*/\1/p' | head -1)
        echo "digest=${DIGEST}" >> $GITHUB_OUTPUT

    - name: Record image metadata
      id: verify-digests
      if: steps.build.outputs.build_success == 'true'
      run: |
        DO_DIGEST="${{ steps.push-do.outputs.digest }}"
        GHCR_DIGEST="${{ steps.push-ghcr.outputs.digest }}"
        DH_DIGEST="${{ steps.push-dh.outputs.digest }}"

        echo "Registry Digests (may differ due to manifest format):"
        echo "  DO:   ${DO_DIGEST}"
        echo "  GHCR: ${GHCR_DIGEST}"
        echo "  DH:   ${DH_DIGEST}"
        echo ""

        # Verify all pushes succeeded
        if [ -z "${DO_DIGEST}" ] || [ -z "${GHCR_DIGEST}" ] || [ -z "${DH_DIGEST}" ]; then
          echo "ERROR: One or more pushes failed to return a digest!"
          echo "image_match=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        # Get local image ID for release notes
        LOCAL_ID=$(docker inspect ${{ env.IMAGE_NAME }}:${{ github.sha }} --format='{{.Id}}')
        echo "Local image ID: ${LOCAL_ID}"
        echo ""

        echo "✅ All pushes completed successfully."
        echo "Digests will be GPG signed for verification."
        echo "image_match=true" >> $GITHUB_OUTPUT
        echo "image_id=${LOCAL_ID}" >> $GITHUB_OUTPUT

    # After registry consistency is verified, add the 'latest' tag.
    - name: Tag as latest after verification
      if: steps.verify-digests.outputs.image_match == 'true'
      run: |          
        # Tag and push 'latest' to each registry.
        # DO Registry
        docker tag \
          "registry.digitalocean.com/${{ env.DO_REGISTRY_NAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" \
          "registry.digitalocean.com/${{ env.DO_REGISTRY_NAME }}/${{ env.IMAGE_NAME }}:latest"
        docker push "registry.digitalocean.com/${{ env.DO_REGISTRY_NAME }}/${{ env.IMAGE_NAME }}:latest"
        
        # GHCR
        docker tag "ghcr.io/${{ github.repository }}:${{ github.sha }}" \
          "ghcr.io/${{ github.repository }}:latest"
        docker push "ghcr.io/${{ github.repository }}:latest"
        
        # Docker Hub
        docker tag "${{ env.DH_USERNAME }}/${{ env.DH_REPO }}:${{ github.sha }}" \
          "${{ env.DH_USERNAME }}/${{ env.DH_REPO }}:latest"
        docker push "${{ env.DH_USERNAME }}/${{ env.DH_REPO }}:latest"
        echo "✅ Successfully tagged all registries with 'latest'"

    - name: Sign release artifacts with GPG
      id: gpg-sign
      if: steps.verify-digests.outputs.image_match == 'true'
      run: |
        echo "Setting up GPG signing ..."

        # Verify required secrets are present
        if [ -z "$GPG_PRIVATE_KEY" ]; then
          echo "❌ GPG_PRIVATE_KEY is not set. GPG signing is mandatory."
          exit 1
        fi

        if [ -z "$GPG_PASSPHRASE" ]; then
          echo "❌ GPG_PASSPHRASE is not set. GPG signing is mandatory."
          exit 1
        fi

        # Import GPG private key (assuming base64 encoded)
        echo "$GPG_PRIVATE_KEY" | base64 -d | \
          gpg --batch --quiet --import 2>/dev/null

        # Get the key ID
        KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | \
          grep sec | awk '{print $2}' | cut -d'/' -f2 | head -1)
        echo "Using GPG key ID: ${KEY_ID: -16}"

        # Create artifacts directory
        mkdir -p release-artifacts

        # Create digest manifest file
        cat > release-artifacts/image-digests.txt <<EOF
        ${{ env.IMAGE_NAME }} Container Image Digests
        Release: ${{ steps.metadata.outputs.timestamp }}-${{ steps.metadata.outputs.sha_short }}
        Git SHA: ${{ github.sha }}
        Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

        Verified Digest (identical across all registries):
        ${{ steps.push-do.outputs.digest }}

        Registry URLs:
        - ghcr.io/${{ github.repository }}@${{ steps.push-ghcr.outputs.digest }}
        - ${{ env.DH_USERNAME }}/${{ env.DH_REPO }}@${{ steps.push-dh.outputs.digest }}
        - registry.digitalocean.com/${{ env.DO_REGISTRY_NAME }}/${{ env.IMAGE_NAME }}@${{ steps.push-do.outputs.digest }}
        EOF

        # Sign the digest manifest
        echo "Signing image-digests.txt ..."
        if gpg --batch --yes --pinentry-mode loopback \
            --passphrase "$GPG_PASSPHRASE" \
            --armor --detach-sign \
            --local-user "$KEY_ID" \
            release-artifacts/image-digests.txt 2>/dev/null; then

          if [ -f release-artifacts/image-digests.txt.asc ]; then
            echo "✅ Created signature: image-digests.txt.asc"
          else
            echo "❌ Failed to create signature file"
            exit 1
          fi
        else
          echo "❌ GPG signing failed for image-digests.txt"
          exit 1
        fi

        # Verify the signature
        if gpg --verify release-artifacts/image-digests.txt.asc \
            release-artifacts/image-digests.txt 2>&1 | \
            grep -q "Good signature"; then
          echo "✅ Signature verified successfully"
        else
          echo "❌ Signature verification failed"
          exit 1
        fi

        # List artifacts
        echo ""
        echo "Signed artifacts:"
        ls -lh release-artifacts/

        echo "signing_success=true" >> $GITHUB_OUTPUT

    - name: Create release
      id: create-release
      if: steps.gpg-sign.outputs.signing_success == 'true'
      uses: actions/github-script@v7
      env:
        RELEASE_NOTES: ${{ steps.release-notes.outputs.RELEASE_NOTES }}
        GPG_PUBLIC_KEY: ${{ env.GPG_PUBLIC_KEY }}
      with:
        github-token: ${{ env.CI_GH_PAT }}
        script: |
          const fs = require('fs');
          const path = require('path');
          const sha = '${{ github.sha }}';
          const timestamp = '${{ steps.metadata.outputs.timestamp }}';
          const shaShort = '${{ steps.metadata.outputs.sha_short }}';

          // Check if we should proceed.
          const doDigest = '${{ steps.push-do.outputs.digest }}';
          const ghcrDigest = '${{ steps.push-ghcr.outputs.digest }}';
          const dhDigest = '${{ steps.push-dh.outputs.digest }}';
          if (!doDigest || !ghcrDigest || !dhDigest) {
            console.log('Missing registry pushes, skipping release.');
            return;
          }
          
          // Get release notes and container push success.
          const releaseNotes = process.env.RELEASE_NOTES || '';
          const gpgPublicKey = process.env.GPG_PUBLIC_KEY || '';
          const containerSuccess = '${{ steps.verify-digests.outputs.image_match }}' === 'true';
          const imageId = '${{ steps.verify-digests.outputs.image_id }}';

          // Prepare the release notes.
          const body = `## Release Notes

          ${releaseNotes}

          ## Container Images

          Images have been pushed to the following container registries; some may be private.
          ${ghcrDigest ? `- GHCR: \`ghcr.io/${{ github.repository }}:${sha}\`` : '- GHCR: ❌'}
          ${dhDigest ? `- DHCR: \`${{ env.DH_USERNAME }}/${{ env.DH_REPO }}:${sha}\`` : '- DHCR: ❌'}
          ${doDigest ? `- DOCR: \`registry.digitalocean.com/${{ env.DO_REGISTRY_NAME }}/${{ env.IMAGE_NAME }}:${sha}\`` : '- DOCR: ❌'}

          \`\`\`bash
          docker pull ghcr.io/${{ github.repository }}@${ghcrDigest}
          docker pull ${{ env.DH_USERNAME }}/${{ env.DH_REPO }}@${dhDigest}
          docker pull registry.digitalocean.com/${{ env.DO_REGISTRY_NAME }}/${{ env.IMAGE_NAME }}@${doDigest}
          \`\`\`

          After pulling from a registry, verify the image ID matches \`${imageId}\` by running \`docker inspect ${{ env.IMAGE_NAME }} --format='{{.Id}}'\`.

          ## GPG Signature Verification

          The image digest manifest is signed with GPG. Download \`image-digests.txt\` and \`image-digests.txt.asc\` from the release assets below. To verify authenticity copy this public key \`${gpgPublicKey}\` into a \`public.asc\` file and verify the signature.
          \`\`\`bash
          # Import GPG public key
          cat public.asc | base64 -d | gpg --import
          gpg --verify image-digests.txt.asc image-digests.txt
          \`\`\`

          A valid signature confirms the digest manifest was signed by the maintainer.
          `;

          const release = await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: `${timestamp}-${shaShort}`,
            name: `${{ env.IMAGE_NAME }} ${shaShort}`,
            body: body,
            draft: false,
            prerelease: !containerSuccess,
            target_commitish: sha
          });
          console.log(`Created release: ${release.data.html_url}`);

          // Upload signed artifacts
          const artifactsDir = 'release-artifacts';
          const artifacts = fs.readdirSync(artifactsDir);
          for (const artifact of artifacts) {
            const artifactPath = path.join(artifactsDir, artifact);
            const stats = fs.statSync(artifactPath);

            if (stats.isFile()) {
              console.log(`Uploading artifact: ${artifact}`);
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: artifact,
                data: fs.readFileSync(artifactPath)
              });
            }
          }

          core.setOutput('RELEASE_SUCCESS', true);
          core.setOutput('RELEASE_ID', release.data.id);

    - name: Rollback on failure
      id: rollback
      if: failure()
      run: |
        echo "⚠️ Inconsistency detected. Attempting to rollback..."
        echo "Will attempt to delete images from registries to maintain" \
          "consistency."

        # Rollback DO if needed.
        DO_ROLLBACK_SUCCESS=true
        if [ ! -z "${{ steps.push-do.outputs.digest }}" ]; then
          echo "Must rollback DO ..."
          export DIGITALOCEAN_ACCESS_TOKEN="${{ env.DO_TOKEN }}"
          if doctl registry repository delete-manifest "${{ env.IMAGE_NAME }}" \
            "${{ steps.push-do.outputs.digest }}" --force; then
            echo "✅ Deleted ${{ steps.push-do.outputs.digest }} from DO"
          else
            echo "❌ Failed to delete from DO"
            DO_ROLLBACK_SUCCESS=false
          fi
        fi

        # Rollback GHCR if needed.
        GHCR_ROLLBACK_SUCCESS=true
        if [ ! -z "${{ steps.push-ghcr.outputs.digest }}" ]; then
          echo "Must rollback GHCR..."

          # Extract owner and package name.
          REPO_OWNER=$(echo "${{ github.repository }}" | cut -d'/' -f1)
          PACKAGE_NAME=$(echo "${{ github.repository }}" | \
            cut -d'/' -f2)
          echo "Looking for package: $REPO_OWNER/$PACKAGE_NAME"

          # Try org first, fall back to user.
          VERSIONS=$(curl -s \
            -H "Authorization: Bearer ${{ env.CI_GH_CLASSIC_PAT }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/orgs/$REPO_OWNER/packages/container/$PACKAGE_NAME/versions")

          # Determine if we're using org or user endpoints.
          ENDPOINT_TYPE="orgs"
          if echo "$VERSIONS" | grep -q "Not Found"; then
            ENDPOINT_TYPE="users"
            VERSIONS=$(curl -s \
              -H "Authorization: Bearer ${{ env.CI_GH_CLASSIC_PAT }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/users/$REPO_OWNER/packages/container/$PACKAGE_NAME/versions")
          fi

          # Count how many versions have tags.
          TAGGED_VERSION_COUNT=$(echo "$VERSIONS" | \
            jq '[.[] | select(.metadata.container.tags and (.metadata.container.tags | length > 0))] | length' \
            2>/dev/null || echo "0")

          # Find the version ID for our SHA tag.
          VERSION_ID=$(echo "$VERSIONS" | jq -r \
            --arg sha "${{ github.sha }}" \
            '.[] | select(.metadata.container.tags[]? == $sha) | .id' \
            2>/dev/null | head -1)

          if [ -n "$VERSION_ID" ] && [ "$VERSION_ID" != "null" ] && \
             [ "$VERSION_ID" != "" ]; then
            echo "Found version ID: $VERSION_ID"

            if [ "$TAGGED_VERSION_COUNT" = "1" ]; then
              echo "⚠️ This is the only tagged version. " \
                "Deleting entire package ..."

              RESPONSE=$(curl -X DELETE \
                -H "Authorization: Bearer ${{ env.CI_GH_CLASSIC_PAT }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/$ENDPOINT_TYPE/$REPO_OWNER/packages/container/$PACKAGE_NAME" \
                -w "\n%{http_code}" -s)

              HTTP_CODE=$(echo "$RESPONSE" | tail -n 1)
              if [ "$HTTP_CODE" = "204" ] || \
                 [ "$HTTP_CODE" = "200" ]; then
                echo "✅ Deleted entire package from GHCR"
              else
                echo "❌ Failed to delete package (HTTP $HTTP_CODE)"
                GHCR_ROLLBACK_SUCCESS=false
              fi
            else
              echo "Found $TAGGED_VERSION_COUNT tagged versions. " \
                "Deleting just version $VERSION_ID..."

              # Delete the specific version.
              RESPONSE=$(curl -X DELETE \
                -H "Authorization: Bearer ${{ env.CI_GH_CLASSIC_PAT }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/$ENDPOINT_TYPE/$REPO_OWNER/packages/container/$PACKAGE_NAME/versions/$VERSION_ID" \
                -w "\n%{http_code}" -s)

              HTTP_CODE=$(echo "$RESPONSE" | tail -n 1)
              if [ "$HTTP_CODE" = "204" ] || \
                 [ "$HTTP_CODE" = "200" ]; then
                echo "✅ Deleted version $VERSION_ID from GHCR"
              else
                echo "❌ Failed to delete from GHCR (HTTP $HTTP_CODE)"
                GHCR_ROLLBACK_SUCCESS=false
              fi
            fi
          else
            echo "❌ Could not find version ID for tag ${{ github.sha }}"
            GHCR_ROLLBACK_SUCCESS=false
          fi
        fi

        # Rollback Docker Hub if needed.
        DH_ROLLBACK_SUCCESS=true
        if [ ! -z "${{ steps.push-dh.outputs.digest }}" ]; then
          echo "Must rollback Docker Hub ..."
          TOKEN=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -d "{\"username\":\"${{ env.DH_USERNAME }}\",\"password\":\"${{ env.DH_TOKEN }}\"}" \
            "https://hub.docker.com/v2/users/login/" | jq -r .token)

          # Delete the specific tag.
          if [ ! -z "$TOKEN" ]; then
            RESPONSE=$(curl -X DELETE \
              -H "Authorization: Bearer $TOKEN" \
              "https://hub.docker.com/v2/repositories/${{ env.DH_USERNAME }}/${{ env.DH_REPO }}/tags/${{ github.sha }}/" \
              -w "\n%{http_code}" -s)

            HTTP_CODE=$(echo "$RESPONSE" | tail -n 1)
            if [ "$HTTP_CODE" = "204" ] || \
               [ "$HTTP_CODE" = "200" ]; then
              echo "✅ Deleted ${{ github.sha }} tag from Docker Hub"
            else
              echo "❌ Failed to delete from Docker Hub (HTTP $HTTP_CODE)"
              DH_ROLLBACK_SUCCESS=false
            fi
          else
            echo "❌ Failed to authenticate with Docker Hub"
            DH_ROLLBACK_SUCCESS=false
          fi
        fi

        # Output the final rollback status.
        echo "do_rollback_success=${DO_ROLLBACK_SUCCESS}" >> $GITHUB_OUTPUT
        echo "ghcr_rollback_success=${GHCR_ROLLBACK_SUCCESS}" >> \
          $GITHUB_OUTPUT
        echo "dh_rollback_success=${DH_ROLLBACK_SUCCESS}" >> $GITHUB_OUTPUT

        echo "========================================="
        if [ "$DO_ROLLBACK_SUCCESS" = true ]; then
          echo "✅ DO rollback success."
        else
          echo "❌ DO rollback failure; manual intervention required."
        fi
        if [ "$GHCR_ROLLBACK_SUCCESS" = true ]; then
          echo "✅ GHCR rollback success."
        else
          echo "❌ GHCR rollback failure; manual intervention required."
        fi
        if [ "$DH_ROLLBACK_SUCCESS" = true ]; then
          echo "✅ Docker Hub rollback success."
        else
          echo "❌ DH rollback failure; manual intervention required."
        fi

        # Always fail, to mark our workflow as failed.
        exit 1

    - name: Create rollback record
      if: failure()
      uses: actions/github-script@v7
      continue-on-error: true
      with:
        github-token: ${{ env.CI_GH_CLASSIC_PAT }}
        script: |
          const shaShort = '${{ steps.metadata.outputs.sha_short }}';
          const timestamp = '${{ steps.metadata.outputs.timestamp }}';
          const buildSuccess =
            ${{ steps.build.outputs.build_success == 'true' }};
          const releaseSuccess =
            ${{ steps.create-release.outputs.RELEASE_SUCCESS == 'true' }};

          const doDigest = '${{ steps.push-do.outputs.digest }}';
          const ghcrDigest = '${{ steps.push-ghcr.outputs.digest }}';
          const dhDigest = '${{ steps.push-dh.outputs.digest }}';

          const doRollback =
            '${{ steps.rollback.outputs.do_rollback_success }}';
          const ghcrRollback =
            '${{ steps.rollback.outputs.ghcr_rollback_success }}';
          const dhRollback =
            '${{ steps.rollback.outputs.dh_rollback_success }}';

          const doRollbackText =
            `- DOCR Rollback: ${doRollback ? '✅' : '❌ manual intervention required.'}`;
          const ghcrRollbackText =
            `- GHCR Rollback: ${ghcrRollback ? '✅' : '❌ manual intervention required.'}`;
          const dhRollbackText =
            `- DHCR Rollback: ${dhRollback ? '✅' : '❌ manual intervention required.'}`;

          // await github.rest.issues.create({
          //   owner: context.repo.owner,
          //   repo: context.repo.repo,
          //   title: `⚠️ Release failed for ${shaShort}`,
          //   body: `# Status
          //
          //   Attention @${{ github.actor }}, an automated release failed. This issue is generated to track the status of build success, partial releases, registry pushes and rollbacks. For full details please refer to [workflow logs](${{ github.server_url }}/${{ github.repository }}/actions).
          //
          //   The automated release process attempts to build the project, push it to various container registries, ensure consistency between the container registries, and release the project.
          //   1. If the build fails, nothing else happens.
          //   2. If successful and consistent pushes to all container registries cannot be verified, a warning-laden partial release of the project is produced. The automated release process will attempt to restore container registry consistency by rolling back the mismatched state.
          //   3. In the event that a registry push succeeded but its corresponding rollback failed, you will need to manually intervene to ensure consistent images between container registries.
          //
          //   ### Build Status
          //   - ${buildSuccess ? '✅ The build succeeded.' : '❌ The build failed.'}
          //   - ${releaseSuccess ? '⚠️ A partial release was made.' : '✅ No release was made.'}
          //
          //   ### Registry Pushes
          //   - DOCR: ${doDigest ? `✅ \`${doDigest}\`` : '❌' }
          //   - GHCR: ${ghcrDigest ? `✅ \`${ghcrDigest}\`` : '❌' }
          //   - DHCR: ${dhDigest ? `✅ \`${dhDigest}\`` : '❌' }
          //
          //   ### Registry Rollbacks
          //   ${doDigest ? doRollbackText : '' }
          //   ${ghcrDigest ? ghcrRollbackText : '' }
          //   ${dhDigest ? dhRollbackText : '' }
          //   `,
          //   labels: ['release-failure', 'needs-investigation']
          // });
